---
title:
subtitle: 
author:
date:
output:
  html_document:
    toc: false
    toc_float: true 
    depth: 2
    number_sections: false
    theme: spacelab
    highlight: pygments
editor_options: 
  markdown: 
    wrap: 150
---

## Session 1 - Basics of data cleaning and mapping using telemetry data

This session will address the fundamentals of data pre-processing and visualisation, utilising the tidyverse, sf, and ggspatial R packages. Participants will learn efficient data cleaning methods, organisation of telemetry data, and the creation of geospatial visualisations to gain insights into animal distributions and movements.

# Load the data 
```{r}
# Load the whale shark data using the 'read.csv' function from local 
# whaleshark <- read.csv('/location of data/Whalesharks_Maldives.csv', header = TRUE)

# Load the whale shark data using the 'read.csv' function directly from github 
whaleshark <- read.csv('https://raw.githubusercontent.com/vinayudyawer/OCS2024_SDMworkshop/main/Data/Whalesharks_Maldives.csv', header = TRUE)
```


# Exploring the data 
```{r}
# Load 'tidyverse' - which we will use for data cleaning, filtering, and visualization 
library(tidyverse)
```

# Alternative reading of csv using tidyverse package
```{r}
# whaleshark <- read_csv('/location of data/Whalesharks_Maldives.csv')

# You can also use read_csv to input data directly from a website URL
whaleshark <- read_csv('https://raw.githubusercontent.com/vinayudyawer/OCS2024_SDMworkshop/main/Data/Whalesharks_Maldives.csv')
```

# Exploring the data 
```{r}
# Now we can use functions in tidyverse to explore, visualize, clean, and filter the data 

# Lets explore first... We can use the 'class' function to see what class our data is in
class(whaleshark)

# Alternatively in the tidyverse we could use this code...
whaleshark %>% class()

# Now lets explore what form each of our columns are in
class(whaleshark$ANIMALID) # character
class(whaleshark$DATE) # character when read.csv but POSIXct when read_csv... INTERESTING. 
class(whaleshark$LONGITUDE) # numeric
class(whaleshark$LATITUDE) # numeric
class(whaleshark$ARGOSCLASS) # character


# Now use piping to visualize other aspects of the data
whaleshark %>% View()
whaleshark %>% head() # first 6 rows by default
whaleshark %>% tail(10) # specify we want to look at the last 10 rows
whaleshark %>% nrow() # number of rows in the data frame
whaleshark %>% ncol() # number of columns in the data frame
whaleshark %>% str() # provides internal structure of an R object
whaleshark %>% summary() # provides result summary of the data frame
```

# Data manipulation and filtering 
```{r}
# pipes can be used for single column within data frames
whaleshark$ANIMALID <-
  whaleshark$ANIMALID %>% as.factor()

# pipes are used to conduct multiple functions on the dataset in a certain order
whaleshark %>% 
  subset(ANIMALID == "M-150") %>% # subset dataset to include only the whale shark 'M-150'
  nrow() # number of rows (i.e. detections) from 'M-150'

```

# Dplyr: using dyplr for data wrangling

Select
```{r}
library(dplyr)

# Select the rows we are interested in

whaleshark %>% 
  dplyr::select(ANIMALID, DATE, LONGITUDE, LATITUDE, ARGOSCLASS)# %>% # columns we want to include
#  select(-ANIMALID) # the minus symbol denotes columns we want to drop

head(whaleshark) # look at our subsetted data

# In this case, our data came pretty tidy and we probably want to hold on to all the columns for now. I've just left the code to remove columns in case anyone wants it. 
```

Filter and arrange
```{r}
# as an example, we could filter to look at the detections of only one of our whale sharks 
whaleshark %>%
  filter(ANIMALID == 'M-150') %>%
  arrange(DATE) # arrange M-150's detections in chronological order

```

Group by and summarise
```{r}
whaleshark %>%
  group_by(ANIMALID) %>%
  summarise(NumDetections = n()) # summarise number of detections per tagged shark

# Now we can see that there is huge variability in number of detections for individuals. Whale shark M-130 has by far the most detections (202), while whale shark M-129 only has four detections. 
```

mutate 
```{r}
# We may want to change the name of the DATE Column to DATETIME or even add another column with just the date or just the time. We can do this using the mutate() function in tidyverse 

whaleshark <-
  whaleshark %>%
  rename(DATETIME = DATE) %>%
  mutate(DATE = as.Date(DATETIME)) %>% # adding a column to the whale shark data with just date of each detection
  mutate(TIME = format(DATETIME, format = "%H:%M:%S"))

```

lubridate ? 
 *Need to figure out what timezone the DATE field is in. 
 *Then see if I need to convert it to be in local time (probably not since its satellite data???)
```{r}
library(lubridate)

#This is old code from vinays SEA 2023 workshop, needs to be ammended. 
whaleshark %>% 
  mutate(local_date_time = with_tz(date_time, tzone = "Australia/Brisbane")) %>% # convert to local "Australia/Brisbane" date time (UTC + 10hrs)
  mutate(date = date(local_date_time)) # use lubridate to update local date time into a date field

```

# Data visualization using ggplot 
```{r}
library(ggplot2)  
```

# Define some colors for individuals 
```{r}
IDcols <- c("#0cb2af", "#a1c65d", "#fac723", "#f29222", "#e95e50", "#936fac")
names(IDcols) <- c("M-111", "M-129", "M-130", "M-149", "M-150", "M-156")
```

# Plot detections per day per individual, and detections date range per individual 
```{r}
whaleshark %>%
  group_by(ANIMALID, DATE) %>% 
  summarise(daily_detections = n()) %>% # use summarise to calculate numbers of detections per day per animal
  ggplot(mapping = aes(x = ANIMALID, y = daily_detections, color = ANIMALID)) + # define the aesthetic map (what to plot)
  scale_color_manual(values = IDcols) +
  xlab("Tag") + ylab("Number of detections per day") +
  geom_boxplot() # define the geometric object (how to plot it).. in this case a boxplot 


whaleshark %>%
  ggplot(mapping = aes(x = DATE, y = ANIMALID, color = ANIMALID)) + 
  scale_color_manual(values = IDcols) +
  xlab("Date") + ylab("Tag") +
  geom_point()

```

# Introduction to the sf package for spatial mapping 

Up until this point, we've been visualizing, manipulating, and cleaning the data by looking at number of individuals, number of detections, and date range of detections. But since this is spatial data, we can look more deeply into the longitude and latitude columns to understand where exactly these animals are. 

Even though people loooooove to analyze spatial data using GIS, R is actually also great for analyzing spatial data, it's just a little harder to wrap your head around. 

The 'sf' package in R was created to make manipulating and analyzing spatial data in R more streamlined and easier, specifically allowing us to convert between dfs and sfs easily. 

```{r}
# First lets load the sf package 
library(sf)
```

# st_as_sf() 
```{r}
# Next we can convert out whale shark data frame into a 'simple feature' (aka a spatial object) using the st_as_sf() function in the sf package 

# In order to use the st_as_sf() function, we need to know the coordinate reference system the data were recorded in. In this case EPSG:3577 aka GDA94 

whaleshark_sf <-
  whaleshark %>% 
    st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs= 3577, remove = F)

# Lets check if it worked...
head(whaleshark_sf)

```

# We can make a simple plot to visualize the points spatially using the ggplot2 package 
```{r}
ggplot(whaleshark_sf, aes(color = ANIMALID)) + 
  geom_sf()
```


# Introduction to the spatial package for spatial mapping 

The above plot is great for visualizing the data but if you want a prettier map, we can use the ggplot2 package combined with the ggspatial package! 

```{r}
library(ggspatial)

ggplot() +
  annotation_map_tile(type = "osm", zoom = 10) +
  layer_spatial(data = whaleshark_sf,aes(color = ANIMALID)) +
  scale_color_manual(values = IDcols) 

```

```{r}
esri_sat <- paste0('') # ??? How do you get the link for this! Super cool though

ggplot() +
  annotation_map_tile(type = esri_sat, zoom = 12) +
  layer_spatial(data = whaleshark_sf) +
  scale_color_manual(values = IDcols) 

```
# Mapview package 

We can use the mapview package to plot interactive maps! 

```{r}
library(mapview)

mapview(whaleshark_sf)
```

```{r}
map1<- 
  mapview(whaleshark_sf,
        alpha.reg = 0.5,
        alpha = 1,
        color = grey,
        fill = grey, 
        map.types = "Esri.WorldImagery",
        legend = F,
        home.button = F,
        cex = 5)

map1@object
map1@map

```

```{r}
library(leaflet)

map2 <- 
  map1@map %>%
    addLayersControl(
      baseGroups = unique(whaleshark_sf$ANIMALID), 
      options = layersControlOptions(collapsed = F)) %>%
  hideGroup(unique(whaleshark_sf$ANIMALID))


# Highlight not working for the individuals... 
```

We can then use the mapshot() function in the mapview package to save our interactive map as a html file or a png output. You can then share the html version of the output to collaborators, or upload them on websites for others to explore your data interactively.

```{r}
mapview::mapshot(map2, url = "Whaleshark_interactive_map.html", remove_controls = NULL, selfcontained = TRUE)

```








